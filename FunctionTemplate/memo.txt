テンプレートの名前解決について
・テンプレートパラメタに依存しない名前の解決は、定義時に行われる
・テンプレートパラメタに依存する名前の解決は、実体化時まで遅延される

テンプレートの依存名（Tとか）の名前解決は実体化場所で行われる。下記の例では定義時点で見えていないFooも使うことはできる。
template < typename T >
void f( T ) { } // テンプレートの定義

struct Foo { } ;

int main()
{
    Foo foo ;
    f( foo ) ; // 実体化場所
}
ただ、発見される名前はテンプレートの定義場所から見える名前に限定されるため、下記はエラー。
// テンプレートの定義
template < typename T >
void call( )
{
    f( 0 ) ; // エラー、名前fが見つからない
} 

void f( int ) { }

int main()
{
    call<void>() ; // 実体化場所
}

例外としてADL[argument dependent name lookup](それが所属している名前空間から探索)が存在する。

テンプレートクラスの継承を行っている場合では、そのテンプレートクラスが宣言された段階ではまだ未確定のクラスになり、親のメンバがどのような形になるのかわからないため、グローバルスコープしか見に行けない。
例えば下記のように書かれるとBase<int>はhoge()を持たない例外が現れるのでスコープとして見ない。
template <class T>
struct Base {
  void hoge(void){
    std::cout << "Hoge" << std::endl;
  }
};

template <class T>
struct Derived : public Base <T> {
  void hogehoge(void){
    hoge(); // (1)
  }
};
template <> 
struct Base <int> {};

よって見るのは、「テンプレートパラメタに依存しない名前の解決は、定義時に行われる」名前解決であり、しかしそれは、コンパイラにとってはテンプレートに全く依存していない(引数などにテンプレートパラメタを含まない)シンボルであるため、親クラスの名前空間を探しにいかず、この例ではグローバル名前空間しか探さないためエラーになる。
解決するにはthis->を使う。
ここでthisはDerived<T>*の型を持っているから、this->修飾されたhoge()はテンプレートパラメタに依存するシンボルとなるため、名前解決はテンプレートの実体化の時(テンプレートパラメタに依存する名前の解決は、実体化時まで遅延される)まで棚上げされる。実体化する時には、親テンプレートクラスも実体化しているので、通常の親クラス、派生クラスの場合と同様に名前解決が可能となる。

テンプレートの定義分離型編成は、すべてのコンパイラでサポートされているわけではない。
→cppとhに分けた構成はコンパイラによってはサポートされない。visualstudioのコンパイラではダメ。
